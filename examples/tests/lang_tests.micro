fn ansi(code text)
	[+] "\x1b[" [+] code [+] "m" [+] text "\x1b[m"
;

fn test(name result)
	outln
		[+] ansi "1" name
		[+] " "
		if result
			fn() ansi "32" "[SUCCESS]";
			fn() ansi "31" "[FAILURE]";
;

test "call" fn()
	== 5 + 2 3
;

test "closure" fn()
	fn add(x y)
		+ x y
	;

	== 5 add 2 3
;

test "closure argument" fn()
	fn apply(operation:2 x y)
		operation x y
	;

	== 5 apply fn(x y) + x y; 2 3
;

test "currying" fn()
	fn add(x):1
		fn(y)
			+ x y
		;
	;

	== 5 add 2 3
;

test "cyclic call" fn()
	fn answer()
		fn()
			42
		;
	;

	== 42 answer
;

test "cyclic call of a closure" fn()
	fn add():0:2
		fn():2
			fn(x y)
				fn()
					+ 2 3
				;
			;
		;
	;

	== 5 add 2 3
;

test "recursion" fn()
	fn sum(start end)
		<<@ as(fn _sum(number limit result)
			if < number limit
				>@fn() _sum ++ number limit + result number;
				fn() result;
		;):3 start end 0
	;

	== 8572599 sum 1234 4321
;

test "assignment" fn()
	let number
		+ 2 3
	;

	== 5 number
;

test "assignment of a closure" fn()
	let add:2
		fn(x y)
			+ x y
		;
	;

	== 5 add 2 3
;

test "cast" fn()
	== 5 as(fn(x y) + x y;):2 2 3
;

test "applying of a closure" fn()
	== 5 apply fn(x y) + x y; ,2,3[]
;

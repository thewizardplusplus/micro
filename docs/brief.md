Micro &mdash; интерпретируемый высокоуровневый язык программирования.
Поддерживает структурную и функциональную парадигмы, обладает строгой
динамической типизацией и сборкой мусора.

### Вызовы функций

Программы на данном языке представляют собой последовательность вызовов функций.
Вызов функции записывается следующим образом:

	function, {argument}

При этом и `function`, и `argument` могут быть либо константами (числовыми или
строковыми), либо точно такими же вызовами функций.

При исполнении сначала вычисляется выражение для самой функции. По результату
определяется арность функции. Затем вычисляется нужное число аргументов. И
наконец они передаются функции.

Например, имеем следующее выражение:

	+ 2 * 5 12

Первой интерпретатор встречает функцию `+`. Она имеет арность 2. Интерпретатор
начинает вычислять 2 аргумента для неё. Первый равен 2. При вычислении второго
же обнаруживается новая функция &mdash; `*`, которая также имеет арность 2.
Поэтому начинается расчёт 2 аргументов уже для функции `*`. Это 5 и 12. После
этого интерпретатор может вычислить результат выражения `* 5 12` (это 60),
который и будет вторым аргументом для функции `+`. Затем интерпретатор может
вычислить результат всего выражения (`+ 2 60`) &mdash; 62.

### Разбиение на токены

Константы:

* числа &mdash; `\d+(?:\.\d+)?`, например: `23`, `4.2`;
* символы &mdash; <code>\`(?:\\.|[^\`])\`</code>, например: <code>\`t\`</code>;
* строки &mdash; `"(?:\\.|[^"])*"`, например: `""`, `"test"`,
`"Say \"Hello!\"."`.

Идентификаторы:

* буквенные &mdash; `/[A-Za-z_]+/ - "fn"`;
* пунктуационные &mdash; <code>/[[:punct:]]+/ - /[\(\);\.\`"_']/</code>.

Таким образом идентификаторы разных типов и любые константы можно чередовать без
разделения их пробелами.

Например, код `#sin2.3` будет преобразован в последовательность токенов
`['#', 'sin', '2.3']`.

### Пользовательские функции

Пользователь может объявлять собственные функции:

	"fn", [name], "(", {parameter}, ")",
		{function call},
	";";

`name` и `parameter` &mdash; любые идентификаторы. Имя функции указывать
необязательно.

Определение функции является одновременно и её вызовом. Таким образом после
обработки определения интерпретатор начнёт вычислять аргументы для вызова
определённой функции.

Если имя функции указано, то данная функция также доступна для вызова и
посредством этого имени. В том числе и внутри себя самой.

Функции можно переопределять.

Результатом выполнения функции является последнее вычисленное внутри неё
значение.

### Замыкания

Внутри функции доступны все идентификаторы из внешних для функции областей
видимости. Если параметры функции имеют имя, совпадающее с одним из этих
идентификаторов, то параметр перекрывает этот идентификатор.

### Переменные

В качестве переменных используются функции вида `fn name() value;`. Они не
требуют аргументов и при вызове просто возвращают сохранённое в них значение.

Для упрощения объявления подобных функций имеется встроенная функция
`=(name value)`. Она полностью эквивалентна вышеприведённой записи.

Также имеется встроенная функция `:=(name value)`. Она аналогична функции `=`,
но объявляет функцию в родительской для текущей функции области видимости.

Для изменения значения переменных используется возможность переопределять
функции.

### Карирование

Для карирования используется оператор `'`. Если интерпретатор встречает данный
оператор на месте очередного аргумента функции, то он прекращает вычисление
аргументов, создаёт новую функцию (замыкание), принимающую оставшиеся аргументы
и возвращает её как результат данного вызова функции.

Так выражение `+ 2'` эквивалентно определению функции `fn(x) + 2 x;`.

Помимо оператора `'` подобным эффектом обладает и недостаток токенов в коде
программы. То есть если интерпретатор при вычислении аргументов функции
встречает конец списка токенов, то он делает тоже самое, что и при встрече
оператора `'`.

Например, функция вида `fn add_x(x) + x';` может быть записана короче (без
оператора `'`): `fn add_x(x) + x;`.

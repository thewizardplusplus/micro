### ![](logo/logo.png) Краткое описание

Micro &mdash; интерпретируемый высокоуровневый язык программирования. Поддерживает функциональную парадигму, обладает сильной полустатической типизацией и сборкой мусора.

#### Вызовы функций

Программы на данном языке представляют собой последовательность вызовов функций. Вызов функции записывается следующим образом:

```
function, {parameter}
```

При этом и `function`, и `parameter` могут быть либо константами (числовыми или строковыми), либо точно такими же вызовами функций.

При исполнении сначала вычисляется выражение для самой функции. По результату определяется арность функции. Затем вычисляется нужное число аргументов. И наконец они передаются функции.

Например, имеем следующее выражение:

```
+ 2 * 5 12
```

Первой интерпретатор встречает функцию `+`. Она имеет арность 2. Интерпретатор начинает вычислять 2 аргумента для неё. Первый равен 2. При вычислении второго же обнаруживается новая функция &mdash; `*`, которая также имеет арность 2. Поэтому начинается расчёт 2 аргументов уже для функции `*`. Это 5 и 12. После этого интерпретатор может вычислить результат выражения `* 5 12` (это 60), который и будет вторым аргументом для функции `+`. Затем интерпретатор может вычислить результат всего выражения (`+ 2 60`) &mdash; 62.

#### Разбиение на токены

Константы:

* числа &mdash; `/\d+(\.\d+)?(e-?\d+)?/` или `/0x[A-Fa-f0-9]+/`, например: `23`, `4.2`, `0x74`;
* символы &mdash; `/'(\\.|\\x[A-Fa-f0-9]{2}|[^'])'/`, например: `'t'`, `'\''`, `'\x74'`;
* строки &mdash; `/"(\\.|\\x[A-Fa-f0-9]{2}|[^"])*"/`, например: `""`, `"test"`, `"Say \"Hello!\"."`, `"\x74es\x74"`.

Идентификаторы:

* буквенные &mdash; `/[a-z_]+/i - ("fn" | "let" | "as")`;
* пунктуационные &mdash; `/[[:punct:]]+/ - /['"_():;]/`.

Идентификаторы разных типов и любые константы можно чередовать без разделения их пробелами. Например, код `~sin2.3` будет преобразован в следующую последовательность токенов: `~`, `sin` и `2.3`.

#### Пользовательские функции

Пользователь может объявлять собственные функции:

```
"fn", [name], "(", {argument, type}, ")", type,
	{entity},
";"
```

`name` и `argument` &mdash; любые идентификаторы. Имя функции указывать необязательно.

Если имя функции указано, то данная функция доступна для вызова посредством этого имени ниже в текущей области видимости, а также внутри себя самой. Анонимные функции доступны для вызова только после передачи их в другие функции в качестве аргументов.

Функции можно переопределять.

Результатом выполнения функции является последнее вычисленное внутри неё значение.

#### Замыкания

Внутри функции доступны все идентификаторы из внешних для функции областей видимости. Если параметры функции имеют имя, совпадающее с одним из этих идентификаторов, то параметр перекрывает этот идентификатор.

#### Переменные

```
"let", [name], type,
	{entity},
";"
```

`name` &mdash; любой идентификатор. Имя переменной указывать необязательно.

Если имя переменной указано, то данная переменная доступна посредством этого имени ниже в текущей области видимости. При этом внутри определения самой себя она доступна не будет.

Присваивание переменным нового значения не поддерживается, но поддерживается переопределение переменных.

Результатом переменной является последнее вычисленное внутри её определения значение.

##### Форсирование вычислений

Основное отличие переменных от замыканий в том, что замыкания вычисляются только в месте своего вызова, в то время как переменные &mdash; непосредственно в месте определения. Таким образом значение переменной вычисляется ровно один раз, а результат замыкания столько раз, сколько раз замыкание было вызвано.

Предположим, мы хотим напечатать одно целое случайное число от 10 до 20 дважды. При помощи замыканий это можно было бы попытаться сделать следующим образом:

```
fn random_number()
	trunc + 10 * 10 random
;

out str random_number
out str random_number
```

Однако при запуске скорее всего получится что-то подобное: `1710`. Так происходит потому, что замыкание random_number вызывается дважды, соответственно, результат её вызова так же разный.

Если же переписать данный пример при помощи переменных:

```
let random_number trunc + 10 * 10 random;
out str random_number
out str random_number
```

То результат будет всегда ожидаемым, например: `1212`.

##### Переопределение переменных

Второе важное отличие переменных от замыканий в том, что именованные замыкания доступны внутри определения самих себя, а именованные переменные нет.

Поэтому при попытке обращения к замыканию внутри него самого произойдёт рекурсивный вызов (подробнее о рекурсии см. ниже). А при попытке обращения к переменной внутри её определения произойдёт обращение к одноимённой переменной, определённой во внешней по отношению к этому определению области видимости.

Допустим, мы хотим прибавить число к некоторой переменной. Используем в качестве переменных замыкания:

```
fn number() 2;           nb (1)
fn number() + number 3;  nb (2)
```

В строке `(2)` внутри определения замыкания есть обращение к замыканию `number`. Можно подумать, что произойдёт обращение к замыканию, определённому в строке `(1)`, однако это не так. Обращение будет к замыканию, определённому в строке `(2)`, и мы получим рекурсивный вызов (и не дождёмся результата).

При использовании же переменных получим иную картину:

```
let number 2;           nb (1)
let number + number 3;  nb (2)
```

Здесь обращение к переменной `number` в строке `(2)`, как и ожидается, будет к переменной, определённой в строке `(1)`. Таким образом после выполнения строки `(2)` значение переменной `number` станет равным 5.

#### Полустатическая типизация

Все значения в языке разделяются на простые и вызываемые. К вызываемым относятся функции арности больше 0, к простым &mdash; все остальные типы и функции арности 0.

Типы для простых значений не указываются. Для вызываемых значений требуется указание типа для аргументов и результата функций. Тип представляет собой список из арности функции и аналогичного типа для результата функции, начинающийся и разделяемый символом `:`.

Например, тип `:5:12:23` обозначает функцию арности 5, которая возвращает функцию арности 12, которая возвращает функцию арности 23.

#### Преобразование типа

```
"as", "(", {entity}, ")", type
```

Преобразование типа позволяет изменить тип выражения. При этом тип меняется только у последнего вычисленного внутри скобок значения. Также вычисление значения производится в месте преобразования (см. форсирование вычислений выше).

При помощи преобразования можно в том числе сделать простое значение вызываемым. Например, имеем следующее определение функции:

```
fn add()
	fn(x y)
		+ x y
	;
;
```

Обратите внимание, что тип результата функции `add` не указан, таким образом данная функция возвращает простое значение. Вызвать данную функцию обычным образом (`add 2 3`) не представляется возможным. Однако при помощи преобразования типа функция может быть вызвана следующим образом:

```
as(add):2 2 3
```

Также преобразование типа удобно использовать для вызова функции непосредственно в месте её определения. Например:

```
as(
	fn(x y)
		+ 2 3
	;
):2 2 3
```

Стоить также заметить, что обратное преобразование, то есть вызываемого значения в простое, невозможно из-за особенностей парсера.

#### Циклический вызов функций

В языке функции арности 0 эквивалентны значению своего результата.

Это означает, что когда интерпретатор встречает функцию арности 0, он начинает циклически её вызывать до тех пор, пока результат вызова не перестанет быть функцией арности 0.

Допустим, имеется определение:

```
fn answer()
	fn()
		fn()
			42
		;
	;
;
```

Тогда, вызов функции `answer` будет эквивалентен значению `42`.

Циклический вызов может остановиться не только на простом значении, но и на вызываемом. Допустим, имеется определение:

```
fn add():0:0:2
	fn():0:2
		fn():2
			fn(x y)
				+ x y
			;
		;
	;
;
```

Тогда, вызов функции `add 2 3` вернёт значение `5`.

#### Рекурсия

Простой рекурсивный вызов невозможен &mdash; интерпретатор имеет низкий предел на глубину рекурсии. Чтобы обойти его, используется упаковка вызовов.

В рантайме имеется функция `>@`, которая упаковывает свой аргумент, не вызывая его. Так как упаковываемый вызов не вычисляется, а результат функции не является функцией, циклического вызова не происходит.

Так же в рантайме имеется функция `<<@`, которая производит циклическую распаковку своего аргумента &mdash; она циклически распаковывает свой аргумент до тех пор, пока результат вызова не перестанет быть упакованным.

Это позволяет заменить рекурсию на циклический вызов. Допустим, нам надо узнать длину списка. Рекурсивный вариант функции:

```
fn size(list)
	fn _size(list result)
		if != [] list
			fn() _size tail list + result 1;
			fn() result;
	;

	_size list 0
;
```

Данный вариант не сможет обрабатывать слишком длинные списки (упрётся в максимальную глубину рекурсии). А вариант функции с упаковкой сможет:

```
fn size(list)
	fn _size(list result)
		if != [] list
			nb рекурсия здесь остановится...
			>@fn() _size tail list + result 1;
			fn() result;
	;

	nb ...а здесь она будет заменена на циклический вызов
	<<@_size list 0
;
```

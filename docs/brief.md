### Краткое описание

Micro &mdash; интерпретируемый высокоуровневый язык программирования. Поддерживает функциональную парадигму, обладает слабой полустатической типизацией и сборкой мусора.

#### Вызовы функций

Программы на данном языке представляют собой последовательность вызовов функций. Вызов функции записывается следующим образом:

```
function, {parameter}
```

При этом и `function`, и `parameter` могут быть либо константами (числовыми или строковыми), либо точно такими же вызовами функций.

При исполнении сначала вычисляется выражение для самой функции. По результату определяется арность функции. Затем вычисляется нужное число аргументов. И наконец они передаются функции.

Например, имеем следующее выражение:

```
+ 2 * 5 12
```

Первой интерпретатор встречает функцию `+`. Она имеет арность 2. Интерпретатор начинает вычислять 2 аргумента для неё. Первый равен 2. При вычислении второго же обнаруживается новая функция &mdash; `*`, которая также имеет арность 2. Поэтому начинается расчёт 2 аргументов уже для функции `*`. Это 5 и 12. После этого интерпретатор может вычислить результат выражения `* 5 12` (это 60), который и будет вторым аргументом для функции `+`. Затем интерпретатор может вычислить результат всего выражения (`+ 2 60`) &mdash; 62.

#### Разбиение на токены

Константы:

* числа &mdash; `/\d+(\.\d+)?(e-?\d+)?/`, например: `23`, `4.2`;
* символы &mdash; `/'(\\['\\tn]|[^'\n])'/`, например: `'t'`, `'\''`;
* строки &mdash; `/"(\\["\\tn]|(?!\\)[^"])*"/`, например: `""`, `"test"`, `"Say \"Hello!\"."`.

Идентификаторы:

* буквенные &mdash; `/[a-z_]+/i - "fn"`;
* пунктуационные &mdash; <code>/[!#$%&*+,\\-.\/<=>?@[\\\\\\]^`{|}~]+/</code>.

Идентификаторы разных типов и любые константы можно чередовать без разделения их пробелами. Например, код `~sin2.3` будет преобразован в следующую последовательность токенов: `~`, `sin` и `2.3`.

#### Пользовательские функции

Пользователь может объявлять собственные функции:

```
"fn", [name], "(", {argument, type}, ")", type,
	{entity},
";"
```

`name` и `argument` &mdash; любые идентификаторы. Имя функции указывать необязательно.

Если имя функции указано, то данная функция доступна для вызова посредством этого имени ниже в текущей области видимости, а также внутри себя самой. Анонимные функции доступны для вызова только после передачи их в другие функции в качестве аргументов.

Функции можно переопределять.

Результатом выполнения функции является последнее вычисленное внутри неё значение.

#### Замыкания

Внутри функции доступны все идентификаторы из внешних для функции областей видимости. Если параметры функции имеют имя, совпадающее с одним из этих идентификаторов, то параметр перекрывает этот идентификатор.

#### Переменные

В качестве переменных используются функции вида `fn name() value;`. Они не требуют аргументов и при вызове просто возвращают сохранённое в них значение.

Для изменения значения переменных используется возможность переопределять функции.

#### Полустатическая типизация

Все значения в языке разделяются на простые и вызываемые. К вызываемым относятся функции арности больше 0, к простым &mdash; все остальные типы и функции арности 0.

Типы для простых значений не указываются. Для вызываемых значений требуется указание типа для аргументов и результата функций. Тип представляет собой список из арности функции и аналогичного типа для результата функции, начинающийся и разделяемый символом `:`.

Например, тип `:5:12:23` обозначает функцию арности 5, которая возвращает функцию арности 12, которая возвращает функцию арности 23.

#### Циклический вызов функций

В языке функции арности 0 эквивалентны значению своего результата.

Это означает, что когда интерпретатор встречает функцию арности 0, он начинает циклически её вызывать до тех пор, пока результат вызова не перестанет быть функцией арности 0.

Допустим, имеется определение:

```
fn answer()
	fn()
		fn()
			42
		;
	;
;
```

Тогда, вызов функции `answer` будет эквивалентен значению `42`.

Циклический вызов может остановиться не только на простом значении, но и на вызываемом. Допустим, имеется определение:

```
fn add():0:0:2
	fn():0:2
		fn():2
			fn(x y)
				+ x y
			;
		;
	;
;
```

Тогда, вызов функции `add 2 3` вернёт значение `5`.

#### Рекурсия

Простой рекурсивный вызов невозможен &mdash; интерпретатор имеет низкий предел на глубину рекурсии. Чтобы обойти его, используется упаковка вызовов.

В рантайме имеется функция `>@`, которая упаковывает свой аргумент, не вызывая его. Так как упаковываемый вызов не вычисляется, а результат функции не является функцией, циклического вызова не происходит.

Так же в рантайме имеется функция `<<@`, которая производит циклическую распаковку своего аргумента &mdash; она циклически распаковывает свой аргумент до тех пор, пока результат вызова не перестанет быть упакованным.

Это позволяет заменить рекурсию на циклический вызов. Допустим, нам надо узнать длину списка. Рекурсивный вариант функции:

```
fn size(list)
	fn _size(list result)
		if != list $
			fn() _size tail list + result 1;
			fn() result;
	;

	_size list 0
;
```

Данный вариант не сможет обрабатывать слишком длинные списки (упрётся в максимальную глубину рекурсии). А вариант функции с упаковкой сможет:

```
fn size(list)
	fn _size(list result)
		if != list $
			nb рекурсия здесь остановится...
			>@fn() _size tail list + result 1;
			fn() result;
	;

	nb ...а здесь она будет заменена на циклический вызов
	<<@_size list 0
;
```

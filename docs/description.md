### ![](logo/logo.png) Общее описание

Micro &mdash; интерпретируемый высокоуровневый язык программирования. Поддерживает функциональную парадигму, обладает сильной полустатической типизацией и сборкой мусора.

#### Исходники

Файлы исходного кода должны быть в кодировке ASCII.

#### Ключевые слова

3 ключевых слова: `fn`, `let`, `as`.

#### Типы

Типизация: сильная полустатическая.

Менеджмент памяти: сборка мусора.

Копирование: по ссылке.

Хранение:

* ссылки &mdash; на стеке;
* значения &mdash; в куче.

##### Нулевой тип

Название: nil.

Тип: фиктивный тип; не хранит значение, а служит маркером его отсутствия; существует единственное значение данного типа.

Определение: значение данного типа доступно через вызов функции рантайма `nil`.

##### Вещественные числа

Название: num.

Тип: с плавающей запятой, 8 байт.

Определение:

```
/\d+(\.\d+)?(e-?\d+)?/
/0x[A-Fa-f0-9]+/
/'(\\.|\\x[A-Fa-f0-9]{2}|[^'])'/
```

##### Списки

Название: list.

Тип: LISP-подобный список &mdash; или пустой список, или пара из головы и хвоста, где голова может иметь любой тип (и является хранимым элементом), а хвост является аналогичным списком.

Определение:

* пустого списка &mdash; через вызов функции рантайма `[]`;
* списка из головы и хвоста &mdash; через вызов функции рантайма `,`.

Доступ к элементам:

* к количеству элементов &mdash; через вызов функции рантайма `size`;
* к голове списка &mdash; через вызов функции рантайма `head`;
* к хвосту списка &mdash; через вызов функции рантайма `tail`;
* к элементу по индексу &mdash; через вызов функции рантайма `.`.

##### Строки

Строками являются списки, хранящие коды символов. Используется кодировка ASCII.

Определение: `/"(\\.|\\x[A-Fa-f0-9]{2}|[^"])*"/`.

##### Хеш-таблицы

Название: hash.

Тип: ассоциативный массив, реализованный через хеш-таблицу; порядок ключей не гарантируется.

Определение:

* пустой хеш-таблицы &mdash; через вызов функции рантайма `{}`;
* новой хеш-таблицы из старой и пары ключа и значения &mdash; через вызов функции рантайма `#`;
* новой хеш-таблицы из старой без определённого ключа &mdash; через вызов функции рантайма `#`.

Доступ:

* к количеству пар ключей и значений &mdash; через вызов функции рантайма `size`;
* к списку ключей &mdash; через вызов функции рантайма `keys`;
* к значению по ключу &mdash; через вызов функции рантайма `.`.

##### Паки

Название: pack.

Тип: обёртка над значением; единственное предназначение &mdash; остановка автоматического вызова замыканий нулевой арности.

Определение: оборачивание значения в пак доступно через вызов функции рантайма `>@`.

Доступ к обёрнутому значению:

* однократный доступ (на один уровень вглубь) &mdash; через вызов функции рантайма `<@`;
* итеративный доступ (на максимальный уровень вглубь) &mdash; через вызов функции рантайма `<<@`; функция итеративно разворачивает значение до тех пор, пока результат является обёрнутым значением.

##### Замыкания

Название: closure.

Объявление:

```
"fn", [identifier], "(", {identifier, {":", INTEGRAL NUMBER}}, ")", {":", INTEGRAL NUMBER},
	{entity},
";"
```

Здесь первый `identifier` &mdash; имя замыкания, по которому оно будет доступно ниже в текущей области видимости, а также внутри самого себя, а все последующие `identifier` &mdash; имена аргументов замыкания.

`{":", INTEGRAL NUMBER}` &mdash; определение типа аргументов замыкания и результата замыкания (в последнем случае). Тип указывается только для замыканий (полустатическая типизация) и является списком арностей этих замыканий и их результатов.

Перегрузка замыканий не поддерживается, но поддерживается их переопределение.

Вызов замыкания: `entity, entity, {entity}`.

Здесь первая `entity` &mdash; идентификатор, являющийся замыканием, или аналогичный вызов замыкания (вложенный вызов), возвращающий замыкание, а все последующие `entity` &mdash; аргументы.

##### Логический тип

В качестве значений логического типа используются значения других типов:

* ложным логическим значением являются:
	* значение `nil`;
	* число 0;
	* пустой список;
	* пустые хеш-таблицы;
* истинным логическим значением являются:
	* числа, отличные от 0;
	* непустые списки;
	* непустые хеш-таблицы;
	* любые паки;
	* любые замыкания.

#### Операции

##### Определение переменных

```
"let", [identifier], {":", INTEGRAL NUMBER},
	{entity},
";"
```

Здесь `identifier` &mdash; имя переменной, по которому она будет доступна ниже в текущей области видимости. При этом внутри определения самой себя она доступна не будет.

`{":", INTEGRAL NUMBER}` &mdash; определение типа переменной. Тип указывается только для замыканий (полустатическая типизация) и является списком арностей этих замыканий и их результатов.

Присваивание переменным нового значения не поддерживается, но поддерживается переопределение переменных.

##### Преобразование типа

```
"as", "(", {entity}, ")", {":", INTEGRAL NUMBER}
```

#### Управляющие конструкции

##### Условие

В качестве условного оператора используется функция рантайма `if`:

```
"if", condition,
	true value,
	false value
```

Здесь:

* `condition` &mdash; это вызов замыкания; его результат трактуется как значение логического типа;
* `true value` &mdash; это вызов замыкания; его значение возвращается, если результат `condition` является истинным логическим значением;
* `false value` &mdash; это вызов замыкания; его значение возвращается, если результат `condition` является ложным логическим значением.

Стоит учесть, что и `true value`, и `false value` вычисляются **до** выбора значения результата. Поэтому, если их вычисление производит побочные эффекты, нужно обернуть их в замыкания:

```
if condition
	fn() true value;
	fn() false value;
```

##### Цикл

Отсутствует.

#### Точка входа

Отсутствует. Интерпретатор исполняет весь предоставленный код в порядке его следования.

#### Комментарии

Однострочные: `/(?<![A-Za-z_])nb(?![:A-Za-z_]).*/`.

Многострочные: `/(?<![A-Za-z_])nb:.*?(?<![A-Za-z_])nb;/s`.

#### Модульность

Тип: включением кода как текста и его последующим исполнением.

Для включения кода используется функция рантайма `load`:

```
load filename
```

Здесь `filename` &mdash; это вызов замыкания, результат которого должен быть строкой и содержать относительный путь к файлу с кодом.

Функция ищет указанный файл, читает его и исполняет, после чего возвращает полученный результат.

Функция кеширует свой результат. Таким образом каждый конкретный файл исполняется только один раз, вне зависимости от того, сколько раз он загружался.

##### Поиск файла

Поиск указанного файла осуществляется в несколько этапов. Функция по очереди перебирает следующие возможные места расположения файла:

* директория того скрипта, из которого был осуществлён вызов функции `load`;
* директория `vendor`, расположенная в директории того скрипта, который был передан интерпретатору;
* директории, указанные в переменной окружения `MICRO_LIBRARY` (перечисляются через символ `:`);
* директория установки pip-пакета интерпретатора.

В каждом месте расположения функция по очереди пытается найти следующие файлы:

* файл, непосредственно указанный в функции `load`;
* файл, указанный в функции `load`, с добавленным расширением `.micro`;
* файл `__main__.micro`, лежащий в директории, указанной в функции `load`.

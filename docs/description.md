Micro &mdash; интерпретируемый высокоуровневый язык программирования.
Поддерживает структурную и функциональную парадигмы, обладает строгой
динамической типизацией и сборкой мусора.

### Исходники

Файлы исходного кода должны быть в кодировке ASCII.

### Ключевые слова

1 ключевое слово: `fn`.

### Типы

Типизация: строгая динамическая.

Менеджмент памяти: сборка мусора.

Копирование: по ссылке.

Хранение:

* ссылки &mdash; на стеке;
* значения &mdash; в куче.

#### Нулевой тип

Название: nil.

Тип: фиктивный тип; не хранит значение, а служит маркером его отсутствия;
существует единственное значение данного типа.

Определение: значение данного типа доступно через вызов функции рантайма
`nil`.

#### Логический тип

Название: bool.

Тип: беззнаковый целый, 1 байт; существует два значения данного типа.

Определение:

* ложное логическое значение доступно через вызов функции рантайма `false`;
* истинное логическое значение доступно через вызов функции рантайма `true`.

Соответствие:

* ложному логическому значению соответствует `nil`, числа `0` и `0.0` и пустой
массив;
* истинному логическому значению соответствуют любые другие значения.

#### Целые числа

Название: int.

Тип: знаковые целые, 8 байт.

Определение:

    /\d+/
    /`(?:\\.|[^`])`/

#### Вещественные числа

Название: num.

Тип: с плавающей запятой, 8 байт.

Определение: `/\d+\.\d+/`.

#### Массивы

Название: list.

Тип: фиксированный массив.

Определение:

* пустого массива &mdash; через вызов функции рантайма `$`;
* массива заданной длины &mdash; через вызов функции рантайма `list`;

Доступ к элементам:

* чтение элементов &mdash; через вызов функции рантайма `get`;
* изменение элементов &mdash; через вызов функции рантайма `set`.

#### Строки

Строками являются массивы, хранящие коды символов. Используется кодировка ASCII.

Определение: `/"(?:\\.|[^"])*"/`.

#### Функции

Название: function.

Объявление:

	"fn", [identify], "(", {parameter}, ")",
		{function call},
	";"

	"=", function name, function call

	":=", function name, function call

	function call, "'"

Здесь `function name` &mdash; это `function call` имеющий результат типа строка.

Перегрузка функций не поддерживается, но поддерживается их переопределение.

Вызов функции: `function name, {argument}`.

Здесь `function name` &mdash; это полноценный `function call`.

### Операции

Операция | Описание | Ассоциативность | Тип(ы) операнда(ов) | Тип результата
--- | --- | --- | --- | ---
`'` | создание замыкания | левая | функции | функции

### Переменные

В качестве переменных используются функции вида `fn name() value;`.

Объявление, определение и присваивание:

* в текущей области видимости &mdash; `"=", name, value`;
* в родительской области видимости &mdash; `":=", name, value`.

Здесь:

* `name` &mdash; это `function call` имеющий результат типа строка;
* `value` &mdash; это полноценный `function call`.

Присваивание осуществляется через переопределение функций.

### Управляющие конструкции

#### Условие

В качестве условного оператора используется функция `if`:

	"if", condition, true value, false value

Здесь:

* `condition` &mdash; это `function call` имеющий результат логического типа;
* `true value` &mdash; это полноценный `function call`, его значение
возвращается, если `condition` равен `true`;
* `false value` &mdash; это полноценный `function call`, его значение
возвращается, если `condition` равен `false`.

Стоит учесть, что и `true value`, и `false value` вычисляются **до** выбора
значения результата. Поэтому, если их вычисление производит побочные эффекты,
нужно обернуть их в замыкание:

	if condition
		fn(_)
			true value
		;'
		fn(_)
			false value
		;'
	nil

#### Цикл

В качестве оператора цикла используется функция `while`:

	"while", condition, body

Здесь:

* `condition` &mdash; это `function call` возвращающий результат типа функция;
эта функция должна быть замыканием, принимающим 1 фиктивный параметр (всегда
передаётся `nil`) и возвращающим результат логического типа;
* `body` &mdash; это `function call` возвращающий результат типа функция;
эта функция должна быть замыканием, принимающим 1 фиктивный параметр (всегда
передаётся `nil`); данная функция вызывается до тех пор, пока `condition`
возвращает `true`.

### Точка входа

Отсутствует. Интерпретатор просто исполняет весь предоставленный код в порядке
его следования.

### Комментарии

Однострочные: `? /\bnb\b.*\n/ ?`.

Многострочные: `? /\bnb:.*\bnb;/ ?`.

### Модульность

Тип: включением кода как текста и его последующим исполнением.

Для включения кода используются функции `require` и `require_once`:

	"require", path

	"require_once", path

Здесь `path` &mdash; это `function call` имеющий результат типа строка. Строка
должна содержать относительный путь к файлу с кодом. Этот путь ищется по пути
расположения файла, переданного интерпретатору.

Функции читают указанный файл и исполняют его, после чего возвращают полученный
результат.

Обе функции кешируют свой результат. При этом функция `require` всё равно каждый
раз читает и исполняет файл заново. А функция `require_once` делает это, только
если для данного файла ещё нет значения в кеше. В противном случае она
возвращает закешированное значение.

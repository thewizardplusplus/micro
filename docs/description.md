### Общее описание

Micro &mdash; интерпретируемый высокоуровневый язык программирования. Поддерживает функциональную парадигму, обладает слабой полустатической типизацией и сборкой мусора.

#### Исходники

Файлы исходного кода должны быть в кодировке ASCII.

#### Ключевые слова

3 ключевых слова: `fn`, `let`, `as`.

#### Типы

Типизация: слабая полустатическая.

Менеджмент памяти: сборка мусора.

Копирование: по ссылке.

Хранение:

* ссылки &mdash; на стеке;
* значения &mdash; в куче.

##### Нулевой тип

Название: nil.

Тип: фиктивный тип; не хранит значение, а служит маркером его отсутствия; существует единственное значение данного типа.

Определение: значение данного типа доступно через вызов функции рантайма `nil`.

##### Вещественные числа

Название: num.

Тип: с плавающей запятой, 8 байт.

Определение:

```
/\d+(\.\d+)?(e-?\d+)?/
/0x[A-Fa-f0-9]+/
/'(\\.|\\x[A-Fa-f0-9]{2}|[^'])'/
```

##### Списки

Название: list.

Тип: LISP-подобный список &mdash; или пустой список, или пара из головы и хвоста, где голова может иметь любой тип (и является хранимым элементом), а хвост является аналогичным списком.

Определение:

* пустого списка &mdash; через вызов функции рантайма `[]`;
* списка из головы и хвоста &mdash; через вызов функции рантайма `,`.

Доступ к элементам:

* к голове списка &mdash; через вызов функции рантайма `head`;
* к хвосту списка &mdash; через вызов функции рантайма `tail`.

##### Строки

Строками являются списки, хранящие коды символов. Используется кодировка ASCII.

Определение: `/"(\\.|\\x[A-Fa-f0-9]{2}|[^"])*"/`.

##### Паки

Название: pack.

Тип: обёртка над значением; единственное предназначение &mdash; остановка автоматического вызова замыканий нулевой арности.

Определение: оборачивание значения в пак доступно через вызов функции рантайма `>@`.

Доступ к обёрнутому значению:

* однократный доступ (на один уровень вглубь) &mdash; через вызов функции рантайма `<@`;
* итеративный доступ (на максимальный уровень вглубь) &mdash; через вызов функции рантайма `<<@`; функция итеративно разворачивает значение до тех пор, пока результат является обёрнутым значением.

##### Замыкания

Название: closure.

Объявление:

```
"fn", [identifier], "(", {identifier, {":", INTEGRAL NUMBER}}, ")", {":", INTEGRAL NUMBER},
	{entity},
";"
```

Здесь первый `identifier` &mdash; имя замыкания, по которому оно будет доступно ниже в текущей области видимости, а также внутри самого себя, а все последующие `identifier` &mdash; имена аргументов замыкания.

`{":", INTEGRAL NUMBER}` &mdash; определение типа аргументов замыкания и результата замыкания (в последнем случае). Тип указывается только для замыканий (полустатическая типизация) и является списком арностей этих замыканий и их результатов.

Перегрузка замыканий не поддерживается, но поддерживается их переопределение.

Вызов замыкания: `entity, entity, {entity}`.

Здесь первая `entity` &mdash; идентификатор, являющийся замыканием, или аналогичный вызов замыкания (вложенный вызов), возвращающий замыкание, а все последующие `entity` &mdash; аргументы.

##### Логический тип

В качестве значений логического типа используются значения других типов:

* ложным логическим значением являются:
	* значение `nil`;
	* число 0;
	* пустой список;
* истинным логическим значением являются:
	* числа, отличные от 0;
	* непустые списки;
	* любые паки;
	* любые замыкания.

#### Операции

##### Определение переменных

```
"let", [identifier], {":", INTEGRAL NUMBER},
	{entity},
";"
```

Здесь `identifier` &mdash; имя переменной, по которому она будет доступна ниже в текущей области видимости, а также внутри определения самой себя.

`{":", INTEGRAL NUMBER}` &mdash; определение типа переменной. Тип указывается только для замыканий (полустатическая типизация) и является списком арностей этих замыканий и их результатов.

Присваивание переменным нового значения не поддерживается, но поддерживается переопределение переменных.

##### Преобразование типа

```
"as", "(", {entity}, ")", {":", INTEGRAL NUMBER}
```

#### Управляющие конструкции

##### Условие

В качестве условного оператора используется функция рантайма `if`:

```
"if", condition,
	true value,
	false value
```

Здесь:

* `condition` &mdash; это вызов замыкания; его результат трактуется как значение логического типа;
* `true value` &mdash; это вызов замыкания; его значение возвращается, если результат `condition` является истинным логическим значением;
* `false value` &mdash; это вызов замыкания; его значение возвращается, если результат `condition` является ложным логическим значением.

Стоит учесть, что и `true value`, и `false value` вычисляются **до** выбора значения результата. Поэтому, если их вычисление производит побочные эффекты, нужно обернуть их в замыкания:

```
if condition
	fn() true value;
	fn() false value;
```

##### Цикл

Отсутствует.

#### Точка входа

Отсутствует. Интерпретатор исполняет весь предоставленный код в порядке его следования.

#### Комментарии

Однострочные: `/(?<![A-Za-z_])nb(?![:A-Za-z_]).*/`.

Многострочные: `/(?<![A-Za-z_])nb:.*?(?<![A-Za-z_])nb;/s`.

#### Модульность

Отсутствует.

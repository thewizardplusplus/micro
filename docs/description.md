Micro &mdash; интерпретируемый высокоуровневый язык программирования.
Поддерживает структурную и функциональную парадигмы, обладает строгой
динамической типизацией и сборкой мусора.

### Исходники

Файлы исходного кода должны быть в кодировке ASCII.

### Ключевые слова

1 ключевое слово: `fn`.

### Типы

Типизация: строгая динамическая.

Менеджмент памяти: сборка мусора.

Копирование: по ссылке.

Хранение:

* ссылки &mdash; на стеке;
* значения &mdash; в куче.

#### Нулевой тип

Название: nil.

Тип: фиктивный тип; не хранит значение, а служит маркером его отсутствия;
существует единственное значение данного типа.

Определение: значение данного типа доступно через вызов функции рантайма
`nil`.

#### Логический тип

Название: bool.

Тип: беззнаковый целый, 1 байт; существует два значения данного типа.

Определение:

* ложное логическое значение доступно через вызов функции рантайма `false`;
* истинное логическое значение доступно через вызов функции рантайма `true`.

Соответствие:

* ложному логическому значению соответствует `nil`, числа `0` и `0.0` и пустой
массив;
* истинному логическому значению соответствуют любые другие значения.

#### Целые числа

Название: int.

Тип: знаковые целые, 8 байт.

Определение:

    /\d+/
    /`(?:\\.|[^`])`/

#### Вещественные числа

Название: num.

Тип: с плавающей запятой, 8 байт.

Определение: `/\d+\.\d+/`.

#### Массивы

Название: list.

Тип: фиксированный массив.

Определение:

* пустого массива &mdash; через вызов функции рантайма `$`;
* массива заданной длины &mdash; через вызов функции рантайма `list`;

Доступ к элементам:

* чтение элементов &mdash; через вызов функции рантайма `get`;
* изменение элементов &mdash; через вызов функции рантайма `set`.

#### Строки

Строками являются массивы, хранящие коды символов. Используется кодировка ASCII.

Определение: `/"(?:\\.|[^"])*"/`.

#### Функции

Название: function.

Объявление:

	"fn", [identify], "(", {parameter}, ")",
		{function call},
	";"

	"=", function name, function call

	":=", function name, function call

	function call, "'"

Здесь `function name` &mdash; это `function call` имеющий результат типа строка.

Перегрузка функций не поддерживается, но поддерживается их переопределение.

Вызов функции: `function name, {argument}`.

Здесь `function name` &mdash; это полноценный `function call`.

### Операции

Операция | Описание | Ассоциативность | Тип(ы) операнда(ов) | Тип результата
--- | --- | --- | --- | ---
`'` | создание замыкания | левая | функции | функции

### Переменные

В качестве переменных используются функции вида `fn name() value;`.

Объявление, определение и присваивание:

* в текущей области видимости &mdash; `"=", name, value`;
* в родительской области видимости &mdash; `":=", name, value`.

Здесь:

* `name` &mdash; это `function call` имеющий результат типа строка;
* `value` &mdash; это полноценный `function call`.

Присваивание осуществляется через переопределение функций.

### Управляющие конструкции

#### Условие

В качестве условного оператора используется функция `if`:

	"if", condition, true value, false value

Здесь:

* `condition` &mdash; это `function call` имеющий результат логического типа;
* `true value` &mdash; это полноценный `function call`, его значение
возвращается, если `condition` равен `true`;
* `false value` &mdash; это полноценный `function call`, его значение
возвращается, если `condition` равен `false`.

Стоит учесть, что и `true value`, и `false value` вычисляются **до** выбора
значения результата. Поэтому, если их вычисление производит побочные эффекты,
нужно обернуть их в замыкание:

	if condition
		fn(_)
			true value
		;'
		fn(_)
			false value
		;'
	nil

#### Цикл

В качестве оператора цикла используется функция `while`:

	"while", condition, body

Здесь:

* `condition` &mdash; это `function call` возвращающий результат типа функция;
эта функция должна быть замыканием, принимающим 1 фиктивный параметр (всегда
передаётся `nil`) и возвращающим результат логического типа;
* `body` &mdash; это `function call` возвращающий результат типа функция;
эта функция должна быть замыканием, принимающим 1 фиктивный параметр (всегда
передаётся `nil`); данная функция вызывается до тех пор, пока `condition`
возвращает `true`.

### Точка входа

Отсутствует. Интерпретатор просто исполняет весь предоставленный код в порядке
его следования.

### Комментарии

Однострочные: `? /\bnb\b.*\n/ ?`.

Многострочные: `? /\bnb:.*\bnb;/ ?`.

### Модульность

Тип: включением кода как текста и его последующим исполнением.

Для включения кода используются функции `require` и `require_once`:

	"require", path

	"require_once", path

Здесь `path` &mdash; это `function call` имеющий результат типа строка. Строка
должна содержать относительный путь к файлу с кодом. Этот путь ищется
относительно текущей рабочей директории.

Функции читают указанный файл и исполняют его, после чего возвращают полученный
результат.

Обе функции кешируют свой результат. При этом функция `require` всё равно каждый
раз читает и исполняет файл заново. А функция `require_once` делает это, только
если для данного файла ещё нет значения в кеше. В противном случае она
возвращает закешированное значение.

### Рантайм

* модуль `lang`:
	* `bool ==(any a, any b)`;
	* `bool !=(any a, any b)`;
	* модуль `lang.types`:
		* `nil nil()`;
		* `str type(any value)` &mdash; возвращает название типа значения
		`value`;
		* `str to_str(any value)`;
		* `num to_num(str text)`;
	* модуль `lang.ops`:
		* `any if(bool condition, any true_value, any false_value)`;
		* `any while(function condition_closure, function body_closure)`;
		* `any eval(str code)`;
		* `any require(str path)`;
		* `any require_once(str path)`;
* модуль `nums`:
	* `int|num #(int|num)` &mdash; унарный минус;
	* `int|num +(int|num x, int|num y)`;
	* `int|num -(int|num x, int|num y)`;
	* `int|num *(int|num x, int|num y)`;
	* `int|num /(int|num x, int|num y)`;
	* `int %(int x, int y)`;
	* `bool <(int|num int|num)`;
	* `bool <=(int|num int|num)`;
	* `bool >(int|num int|num)`;
	* `bool >=(int|num int|num)`;
	* модуль `nums.maths`:
		* `num floor(int|num number)`;
		* `num ceil(int|num number)`;
		* `int trunc(int|num number)`;
		* `num sin(int|num number)`;
		* `num cos(int|num number)`;
		* `num tn(int|num number)`;
		* `num arcsin(int|num number)`;
		* `num arccos(int|num number)`;
		* `num arctn(int|num number)`;
		* `num arctn2(int|num y, int|num x)`;
		* `num sh(int|num number)`;
		* `num ch(int|num number)`;
		* `num th(int|num number)`;
		* `num sqrt(int|num number)`;
		* `num pow(int|num base, int|num exponent)`;
		* `num exp(int|num number)`;
		* `num ln(int|num number)`;
		* `num lg(int|num number)`;
		* `num abs(int|num number)`;
		* `num rand()` &mdash; возвращает случайное число в диапазоне [0; 1);
* модуль `bools`:
	* `bool true()`;
	* `bool false()`;
	* `any &&(any a, any b)` &mdash; если `a` соответствует `false`, возвращает
	`a`, иначе `b`;
	* `any ||(any a, any b)` &mdash; если `a` соответствует `true`, возвращает
	`a`, иначе `b`;
	* `bool !(any a)`;
* модуль `lists`:
	* `list $()` &mdash; создаёт пустой массив;
	* `list :(any value, list array)` &mdash; создаёт массив из головы `value` и
	хвоста `array`;
	* `list list(int number, any value)` &mdash; создаёт массив длиной `number`
	и заполняет его значением `value`;
	* `list append(list array, any value)`;
	* `list concat(list array_1, list array_2)`;
	* `any get(list array, int index)`;
	* `list set(list array, int index, any value)`;
	* `int len(list array)`;
* модуль `sys`:
	* `list args()` &mdash; содержит список аргументов командной строки,
	переданый скрипту; первый элемент списка содержит путь к файлу скрипта;
	* `nil exit(int code)`;
	* модуль `sys.io`:
		* `int read()` &mdash; читает 1 символ из `stdin`;
		* `str print(str text)`.

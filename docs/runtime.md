### Рантайм

* общие функции:
	* `==(x: any, y: any): bool` &mdash; равенство;
	* `!=(x: any, y: any): bool` &mdash; неравенство;
	* `!(x: any): bool` &mdash; логическое отрицание;
	* `&&(x: any, y: any): bool` &mdash; конъюнкция;
	* `||(x: any, y: any): bool` &mdash; дизъюнкция;
	* `if(condition: bool, true_value: any, false_value: any): bool` &mdash; выбор: если `condition` истинно, возвращает `true_value`, иначе &mdash; `false_value`;
	* `+(x: num|list<any>|hash<any, any>, y: num|list<any>|hash<any, any>): num|list<any>|hash<any, any>` &mdash; возвращает результат комбинирования переданных аргументов:
		* если оба аргумента имеют тип `num`, то функция возвращает результат их сложения;
		* если оба аргумента имеют тип `list<any>`, то функция возвращает результат их конкатенации;
		* если оба аргумента имеют тип `hash<any, any>`, то функция возвращает результат их слияния;
	* `size(x: list<any>|hash<any, any>|pack<any>): num` &mdash; возвращает размер (длину) переданного аргумента;
	* функции для работы с типами:
		* `nil(): nil` &mdash; возвращает значение нулевого типа;
		* `false(): bool` &mdash; возвращает ложное логическое значение (число 0);
		* `true(): bool` &mdash; возвращает истинное логическое значение (число 1);
		* `type(x: any): str` &mdash; возвращает имя типа переданного значения;
		* `arity(x: closure): list<num>` &mdash; возвращает список арностей переданного замыкания (голова списка &mdash; арность самого замыкания, хвост &mdash; аналогичный список для результата замыкания);
* числовые функции:
	* `<(x: num, y: num): bool` &mdash; меньше;
	* `<=(x: num, y: num): bool` &mdash; меньше или равно;
	* `>(x: num, y: num): bool` &mdash; больше;
	* `>=(x: num, y: num): bool` &mdash; больше или равно;
	* `_(x: num): num` &mdash; унарный минус;
	* `++(x: num): num` &mdash; инкремент;
	* `--(x: num): num` &mdash; декремент;
	* `-(x: num, y: num): num` &mdash; вычитание;
	* `*(x: num, y: num): num` &mdash; умножение;
	* `/(x: num, y: num): num` &mdash; деление;
	* `%(x: num, y: num): num` &mdash; остаток от деления;
	* битовые функции:
		* `&(x: num, y: num): num` &mdash; побитовое И;
		* `|(x: num, y: num): num` &mdash; побитовое ИЛИ;
		* `^(x: num, y: num): num` &mdash; побитовое исключающее ИЛИ;
		* `<<(x: num, y: num): num` &mdash; сдвиг влево;
		* `>>(x: num, y: num): num` &mdash; арифметический сдвиг вправо;
		* `>>>(x: num, y: num): num` &mdash; логический сдвиг вправо;
		* `~(x: num): num` &mdash; побитовое НЕ;
	* математические функции:
		* `floor(x: num): num`;
		* `ceil(x: num): num`;
		* `trunc(x: num): num`;
		* `round(x: num): num`;
		* `sin(x: num): num`;
		* `cos(x: num): num`;
		* `tn(x: num): num`;
		* `arcsin(x: num): num`;
		* `arccos(x: num): num`;
		* `arctn(x: num): num`;
		* `angle(y: num, x: num): num` &mdash; atan2;
		* `pow(base: num, exponent: num): num`;
		* `sqrt(x: num): num`;
		* `exp(x: num): num`;
		* `ln(x: num): num`;
		* `lg(x: num): num`;
		* `abs(x: num): num`;
		* `random(): num` &mdash; возвращает случайное число в диапазоне [0; 1);
* функции для работы со списками:
	* `[](): list<any>` &mdash; возвращает пустой список;
	* `,(head: any, tail: list<any>): list<any>` &mdash; конструирует новый список из переданных головы и хвоста;
	* `head(list: list<any>): any` &mdash; возвращает голову переданного списка;
	* `tail(list: list<any>): list<any>` &mdash; возвращает хвост переданного списка;
* функции для работы со строками:
	* `num(x: str): num` &mdash; парсит число из строки;
	* `str(x: any): str` &mdash; преобразует переданное значение в строку;
	* `strb(x: bool): str` &mdash; преобразует переданное логическое значение в строку: если `x` истинно, возвращает `"true"`, иначе &mdash; `"false"`;
	* `strs(x: str): str` &mdash; преобразует переданную строку в другую строку, экранируя её символы и окружая всю строку кавычками;
	* `strl(x: list<str>): str` &mdash; преобразует переданный список строк в строку, отображая при этом строки как строки;
	* `strh(x: hash<str, any>): str` &mdash; преобразует переданную хеш-таблицу, у которой ключи имеют строковый тип, в строку, отображая при этом ключи как строки;
	* `strhh(x: hash<str, str>): str` &mdash; преобразует переданную хеш-таблицу, у которой и ключи, и значения имеют строковый тип, в строку, отображая при этом и ключи, и значения как строки;
* функции для работы с хеш-таблицами:
	* `{}(): hash<any, any>` &mdash; возвращает пустую хеш-таблицу;
	* `#(key: any, value: any, hash: hash<any, any>): hash<any, any>` &mdash; если `value` не равно `nil`, то возвращает новую хеш-таблицу, в которую было добавлено значение `value` с ключом `key`; если `value` равно `nil`, то возврашает новую хеш-таблицу, из которой было удалено значение с ключом `key`;
	* `.(key: any, hash: hash<any, any>): any` &mdash; если ключ `key` присутствует в хеш-таблице `hash`, то возвращает соответствующее ему значение; в противном случае возвращает `nil`;
	* `keys(hash: hash<any, any>): list<any>` &mdash; возвращает список ключей хеш-таблицы `hash`;
* функции для упаковки:
	* `>@(x: any): pack<any>` &mdash; упаковывает переданное значение без его предварительного вычисления;
	* `<@(x: pack<any>): any` &mdash; распаковывает переданное значение;
	* `<<@(x: pack<any>): any` &mdash; распаковывает переданное значение в цикле до тех пор, пока результат является упакованным значением;
* системные функции:
	* `args(): list<str>` &mdash; возвращает список аргументов командной строки, причём первым аргументом будет путь к файлу скрипта; если же код скрипта был прочитан с stdin, первым аргументом будет строка `"stdin"`;
	* `env(name: str): str|nil` &mdash; возвращает значение указанной переменной окружения, если она установлена; в противном случае возвращается `nil`;
	* `time(): num` &mdash; возвращает текущее UNIX-время по UTC;
	* `exit(status: nil|num|str): nil` &mdash; завершает выполнение скрипта; дополнительное поведение зависит от переданного статуса:
		* если `status` равен `nil`, то код возврата будет равен 0;
		* если `status` имеет тип `num` и находится в диапазоне [0, 127], то код возврата будет равен `status`;
		* если `status` имеет тип `str`, то код возврата будет равен 1, а `status` будет выведен в stderr (вместе с дополнительным символом `'\n'` в конце);
	* функции для ввода/вывода:
		* `in(number: nil|num): str` &mdash; считывает указанное количество символов из stdin и возвращает их в виде строки; если количество будет отрицательным или вместо него будет передан `nil`, то будут считаны все доступные символы;
		* `inln(number: nil|num): str` &mdash; считывает указанное количество символов из stdin и возвращает их в виде строки; если количество будет отрицательным или вместо него будет передан `nil`, то будут считаны все символы до символа `'\n'` или, если он отсутствует, все доступные символы;
		* `out(string: str): nil` &mdash; выводит переданную строку в stdout;
		* `outln(string: str): nil` &mdash; выводит переданную строку в stdout и переводит строку (добавляет символ `'\n'`);
		* `err(string: str): nil` &mdash; выводит переданную строку в stderr;
		* `errln(string: str): nil` &mdash; выводит переданную строку в stderr и переводит строку (добавляет символ `'\n'`).

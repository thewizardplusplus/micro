### ![](logo/logo.png) Рантайм

* общие функции:
	* `nil(): nil` &mdash; возвращает значение нулевого типа;
	* `type(x: any): str` &mdash; возвращает имя типа переданного значения;
	* `==(x: any, y: any): bool` &mdash; равенство;
	* `!=(x: any, y: any): bool` &mdash; неравенство;
	* `!(x: any): bool` &mdash; логическое отрицание;
	* `&&(x: any, y: any): any` &mdash; конъюнкция; функция является ленивой &mdash; `y` вычисляется только при необходимости (то есть когда `x` истинен); возвращается вычисленное значение;
	* `||(x: any, y: any): any` &mdash; дизъюнкция; функция является ленивой &mdash; `y` вычисляется только при необходимости (то есть когда `x` ложен); возвращается вычисленное значение;
	* `?(value: any, default: any): any` &mdash; возвращает `value`, если оно не равно `nil`; в противном случае возвращается `default`;
	* `if(condition: bool, true_value: any, false_value: any): any` &mdash; выбор: если `condition` истинно, возвращает `true_value`, иначе &mdash; `false_value`; функция является ленивой &mdash; вычисляется только возвращаемое значение;
	* `+(x: num|list<any>|hash<any, any>, y: num|list<any>|hash<any, any>): num|list<any>|hash<any, any>` &mdash; возвращает результат комбинирования переданных аргументов:
		* если оба аргумента имеют тип `num`, то функция возвращает результат их сложения;
		* если оба аргумента имеют тип `list<any>`, то функция возвращает результат их конкатенации;
		* если оба аргумента имеют тип `hash<any, any>`, то функция возвращает результат их слияния;
	* `size(x: list<any>|hash<any, any>|pack<any>): num` &mdash; возвращает размер (длину) переданного аргумента;
	* `.(index: any, container: list<any>|hash<any, any>|pack<any>): any` &mdash; возвращает элемент `index` из контейнера `container`:
		* если `container` имеет тип `list<any>`, то функция возвращает элемент с индексом `index`; если индекс отрицателен, он трактуется как номер элемента с конца списка; если индекс выходит за границы списка, то функция возвращает `nil`;
		* если `container` имеет тип `hash<any, any>`, то функция возвращает соответствующее ключу `index` значение; если указанный ключ отсутствует в хеш-таблице, функция возвращает `nil`;
		* если `container` имеет тип `pack<any>`, то он трактуется как список длиной 1;
* функции для работы с логическими значениями:
	* `false(): bool` &mdash; возвращает ложное логическое значение (число 0);
	* `true(): bool` &mdash; возвращает истинное логическое значение (число 1);
	* `bool(x: any): bool` &mdash; преобразует значение в логический тип: возвращает строго 0 или 1;
* функции для работы с числами:
	* `<(x: num, y: num): bool` &mdash; меньше;
	* `<=(x: num, y: num): bool` &mdash; меньше или равно;
	* `>(x: num, y: num): bool` &mdash; больше;
	* `>=(x: num, y: num): bool` &mdash; больше или равно;
	* `_(x: num): num` &mdash; унарный минус;
	* `++(x: num): num` &mdash; инкремент;
	* `--(x: num): num` &mdash; декремент;
	* `-(x: num, y: num): num` &mdash; вычитание;
	* `*(x: num, y: num): num` &mdash; умножение;
	* `/(x: num, y: num): num` &mdash; деление;
	* `%(x: num, y: num): num` &mdash; остаток от деления;
	* битовые функции:
		* `&(x: num, y: num): num` &mdash; побитовое И;
		* `|(x: num, y: num): num` &mdash; побитовое ИЛИ;
		* `^(x: num, y: num): num` &mdash; побитовое исключающее ИЛИ;
		* `<<(x: num, y: num): num` &mdash; сдвиг влево;
		* `>>(x: num, y: num): num` &mdash; арифметический сдвиг вправо;
		* `>>>(x: num, y: num): num` &mdash; логический сдвиг вправо;
		* `~(x: num): num` &mdash; побитовое НЕ;
	* математические функции:
		* математические константы:
			* `nan(): num`;
			* `inf(): num`;
			* `pi(): num`;
			* `e(): num`;
		* `floor(x: num): num`;
		* `ceil(x: num): num`;
		* `trunc(x: num): num`;
		* `round(x: num): num`;
		* `sin(x: num): num`;
		* `cos(x: num): num`;
		* `tn(x: num): num`;
		* `arcsin(x: num): num`;
		* `arccos(x: num): num`;
		* `arctn(x: num): num`;
		* `angle(y: num, x: num): num` &mdash; atan2;
		* `pow(base: num, exponent: num): num`;
		* `sqrt(x: num): num`;
		* `exp(x: num): num`;
		* `ln(x: num): num`;
		* `lg(x: num): num`;
		* `abs(x: num): num`;
		* `is_nan(x: num): bool`;
		* генерация псевдослучайных чисел:
			* `seed(x: any): nil` &mdash; устанавливает начальное состояние генератора псевдослучайных чисел; если `x` равен `nil`, то для генерации начального состояния используется системный источник энтропии, а если тот недоступен &mdash; системное время; если `x` имеет любое другое значение, то для генерации начального состояния используется хеш от `x`;
			* `random(): num` &mdash; возвращает псевдослучайное число в диапазоне [0; 1);
* функции для работы со списками:
	* `[](): list<any>` &mdash; возвращает пустой список;
	* `,(head: any, tail: list<any>): list<any>` &mdash; конструирует новый список из переданных головы и хвоста;
	* `head(list: list<any>): any` &mdash; возвращает голову переданного списка, если он не пуст; в противном случае возвращается `nil`;
	* `tail(list: list<any>): nil|list<any>` &mdash; возвращает хвост переданного списка, если он не пуст; в противном случае возвращается `nil`;
* функции для работы со строками:
	* `num(x: str): num` &mdash; парсит число из строки;
	* `str(x: any): str` &mdash; преобразует переданное значение в строку;
	* `strb(x: bool): str` &mdash; преобразует переданное логическое значение в строку: если `x` истинно, возвращает `"true"`, иначе &mdash; `"false"`;
	* `strs(x: str): str` &mdash; преобразует переданную строку в другую строку, экранируя её символы и окружая всю строку кавычками;
	* `strl(x: list<str>): str` &mdash; преобразует переданный список строк в строку, отображая при этом строки как строки;
	* `strh(x: hash<str, any>): str` &mdash; преобразует переданную хеш-таблицу, у которой ключи имеют строковый тип, в строку, отображая при этом ключи как строки;
	* `strhh(x: hash<str, str>): str` &mdash; преобразует переданную хеш-таблицу, у которой и ключи, и значения имеют строковый тип, в строку, отображая при этом и ключи, и значения как строки;
* функции для работы с хеш-таблицами:
	* `{}(): hash<any, any>` &mdash; возвращает пустую хеш-таблицу;
	* `#(key: any, value: any, hash: hash<any, any>): hash<any, any>` &mdash; если `value` не равно `nil`, то возвращает новую хеш-таблицу, в которую было добавлено значение `value` с ключом `key`; если `value` равно `nil`, то возврашает новую хеш-таблицу, из которой было удалено значение с ключом `key`;
	* `keys(hash: hash<any, any>): list<any>` &mdash; возвращает список ключей хеш-таблицы `hash`;
* функции для упаковки:
	* `>@(x: any): pack<any>` &mdash; упаковывает переданное значение без его предварительного вычисления;
	* `<@(x: pack<any>): any` &mdash; распаковывает переданное значение;
	* `<<@(x: pack<any>): any` &mdash; распаковывает переданное значение в цикле до тех пор, пока результат является упакованным значением;
* системные функции:
	* `load(filename: str): any` &mdash; загружает файл скрипта `filename`, выполняет его и возвращает полученный результат;
	* `args(): list<str>` &mdash; возвращает список аргументов командной строки, причём первым аргументом будет путь к файлу скрипта; если же код скрипта был прочитан с stdin, первым аргументом будет строка `"stdin"`;
	* `env(name: str): nil|str` &mdash; возвращает значение указанной переменной окружения, если она установлена; в противном случае возвращается `nil`; также интерпретатором осуществляется загрузка `.env`-конфига из текущей рабочей директории;
	* `time(): num` &mdash; возвращает текущее UNIX-время по UTC;
	* `sleep(seconds: num): nil` &mdash; останавливает выполнение скрипта на указанное количество секунд; `seconds` может быть вещественным числом;
	* `exit(status: nil|num|str): nil` &mdash; завершает выполнение скрипта; дополнительное поведение зависит от переданного статуса:
		* если `status` равен `nil`, то код возврата будет равен 0;
		* если `status` имеет тип `num` и находится в диапазоне [0, 127], то код возврата будет равен `status`;
		* если `status` имеет тип `str`, то код возврата будет равен 1, а `status` будет выведен в stderr (вместе с дополнительным символом `'\n'` в конце);
	* функции для ввода/вывода:
		* `in(number: nil|num): str` &mdash; считывает указанное количество символов из stdin и возвращает их в виде строки; если количество будет отрицательным или вместо него будет передан `nil`, то будут считаны все доступные символы;
		* `inln(number: nil|num): str` &mdash; считывает указанное количество символов из stdin и возвращает их в виде строки; если количество будет отрицательным или вместо него будет передан `nil`, то будут считаны все символы до символа `'\n'` или, если он отсутствует, все доступные символы;
		* `out(string: str): nil` &mdash; выводит переданную строку в stdout;
		* `outln(string: str): nil` &mdash; выводит переданную строку в stdout и переводит строку (добавляет символ `'\n'`);
		* `err(string: str): nil` &mdash; выводит переданную строку в stderr;
		* `errln(string: str): nil` &mdash; выводит переданную строку в stderr и переводит строку (добавляет символ `'\n'`).

let map:2 load "std/list/map";
let filter:2 load "std/list/filter";
let zip_longest:3 load "std/list/zip_longest";
let reduce:3 load "std/list/reduce";

fn d(t~r)#"path"t#"action"~ #"parameters"r{};
fn@(n~)|| !=type n type~fn()if=="hash"type n fn()!= ."type"n."type"~;fn()!=n~;;;
fn$(~a@e)if!e fn()d~"remove_property",a[];fn()if|| ! @ !=e@fn()d~"set_property",a,e[];fn();;;
fn%(p o~)let@ +o~;let#map keys@fn(n)$p n.n o.n~;;filter#fn(d)d;;

#"make_node"fn(k~c)#"type"k#"properties"~ #"children"c{};
#"compare_nodes"fn=(o n i~)
if!o fn(),d~"create",n[] [];fn()
if!n fn(),d~"remove",i[] [];fn()
if@o n fn(),d~"replace",i,n[] [];fn()
if=="hash"type o fn()
let c+ ~ , ."type"o[];
let p%c."properties"o."properties"n;
let^zip_longest."children"o."children"n fn(a b),a,b[];;
let&let*reduce{} ^fn(r~)
let i?? ."index"r0;
let d= .0~ .1~i c;
#"differences"+ ?? ."differences"r[]d#"index"++i{}
;;?? ."differences"* [];+p&;fn()[];;;;;{}

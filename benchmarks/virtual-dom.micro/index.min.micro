let map:2 load "std/list/map";
let filter:2 load "std/list/filter";
let zip_longest:3 load "std/list/zip_longest";
let reduce:3 load "std/list/reduce";

fn d(t~r)#"path"t#"action"~ #"parameters"r{};
fn@(n~)|| !=type n type~fn()if=="hash"type n fn()!= ."type"n."type"~;fn()!=n~;;;
fn$(~a@e)if!e fn()d~"remove_property",a[];fn()if|| ! @ !=e@fn()d~"set_property",a,e[];fn();;;
fn%(p o~)let@ +o~;let#map keys@fn(n)$p n.n o.n~;;filter#fn(d)d;;

fn compare_nodes(o n i~)
	if!o fn(),d~"create",n[] [];fn()
		if!n fn(),d~"remove",i[] [];fn()
			if@o n fn(),d~"replace",i,n[] [];fn()
				if=="hash"type o fn()
					let child_path + ~ , ."type"o [];
					let properties_differences
						%
							child_path
							."properties"o
							."properties"n
					;
					let children_pairs
						zip_longest
							."children"o
							."children"n
							fn(node_i node_ii)
								,node_i,node_ii[]
							;
					;
					let children_differences
						let result
							reduce {} children_pairs fn(result children_pair)
								let index ?? ."index"result 0;
								let differences
									compare_nodes
										.0 children_pair
										.1 children_pair
										index
										child_path
								;

								#"differences" + ?? ."differences"result [] differences
								#"index" ++ index
							{};
						;

						?? ."differences"result []
					;

					+ properties_differences children_differences
				;fn()[];
			;
		;
	;
;

	#"make_node"fn(k~c)#"type"k#"properties"~ #"children"c{};
	#"compare_nodes" fn(old_node new_node index path)
		compare_nodes old_node new_node index path
	;
{}
